

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Pharmaledger's Finished Goods Traceability Wholesaler SSApp resources/ionic-core/dist/collection/utils/overlays.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
             
                <a href="index.html">
                    <h1 class="navbar-item">Pharmaledger's Finished Goods Traceability Wholesaler SSApp</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                 
                    
                        <a
                            class="link user-link "
                            href="https://github.com/PharmaLedger-IMI/fgt-workspace/fgt-wholesaler-ssapp.git"
                        >
                            Github
                        </a>
                    
                        <a
                            class="link user-link "
                            href="https://fgt.pharmaledger.pdmfc.com/fgt-wholesaler-wallet/loader"
                        >
                            Application
                        </a>
                    
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="ActionSheet.html">ActionSheet</a></li><li><a href="Alert.html">Alert</a></li><li><a href="BackButton.html">BackButton</a></li><li><a href="Badge.html">Badge</a></li><li><a href="Button.html">Button</a></li><li><a href="Card.html">Card</a></li><li><a href="CardContent.html">CardContent</a></li><li><a href="CardHeader.html">CardHeader</a></li><li><a href="CardSubtitle.html">CardSubtitle</a></li><li><a href="CardTitle.html">CardTitle</a></li><li><a href="Checkbox.html">Checkbox</a></li><li><a href="Chip.html">Chip</a></li><li><a href="Content.html">Content</a></li><li><a href="Datetime.html">Datetime</a></li><li><a href="Dom7.html">Dom7</a></li><li><a href="FabButton.html">FabButton</a></li><li><a href="Footer.html">Footer</a></li><li><a href="Header.html">Header</a></li><li><a href="global.html#ImageCapture">ImageCapture</a></li><li><a href="Img.html">Img</a></li><li><a href="Input.html">Input</a></li><li><a href="Item.html">Item</a></li><li><a href="ItemDivider.html">ItemDivider</a></li><li><a href="ItemOption.html">ItemOption</a></li><li><a href="Label.html">Label</a></li><li><a href="List.html">List</a></li><li><a href="ListHeader.html">ListHeader</a></li><li><a href="Loading.html">Loading</a></li><li><a href="Menu.html">Menu</a></li><li><a href="MenuButton.html">MenuButton</a></li><li><a href="Modal.html">Modal</a></li><li><a href="module.exports.html">exports</a></li><li><a href="Note.html">Note</a></li><li><a href="Picker.html">Picker</a></li><li><a href="PickerColumnCmp.html">PickerColumnCmp</a></li><li><a href="Popover.html">Popover</a></li><li><a href="ProgressBar.html">ProgressBar</a></li><li><a href="Radio.html">Radio</a></li><li><a href="Range.html">Range</a></li><li><a href="Reorder.html">Reorder</a></li><li><a href="Searchbar.html">Searchbar</a></li><li><a href="Segment.html">Segment</a></li><li><a href="SegmentButton.html">SegmentButton</a></li><li><a href="Select.html">Select</a></li><li><a href="SelectPopover.html">SelectPopover</a></li><li><a href="Slides.html">Slides</a></li><li><a href="TabBar.html">TabBar</a></li><li><a href="TabButton.html">TabButton</a></li><li><a href="Tabs.html">Tabs</a></li><li><a href="Text.html">Text</a></li><li><a href="Textarea.html">Textarea</a></li><li><a href="Toast.html">Toast</a></li><li><a href="Toggle.html">Toggle</a></li><li><a href="Toolbar.html">Toolbar</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_expandUnicodeEscapes">_expandUnicodeEscapes</a></li><li><a href="global.html#a">a</a></li><li><a href="global.html#baseAnimation">baseAnimation</a></li><li><a href="global.html#bindLocale">bindLocale</a></li><li><a href="global.html#blockHardwareBackButton">blockHardwareBackButton</a></li><li><a href="global.html#clean">clean</a></li><li><a href="global.html#componentOnReady">componentOnReady</a></li><li><a href="global.html#convertToArrayOfNumbers">convertToArrayOfNumbers</a></li><li><a href="global.html#convertToArrayOfStrings">convertToArrayOfStrings</a></li><li><a href="global.html#copyVisualViewport">copyVisualViewport</a></li><li><a href="global.html#createColorClasses">createColorClasses</a></li><li><a href="global.html#EMPTY_OBJ">EMPTY_OBJ</a></li><li><a href="global.html#fireKeyboardCloseEvent">fireKeyboardCloseEvent</a></li><li><a href="global.html#fireKeyboardOpenEvent">fireKeyboardOpenEvent</a></li><li><a href="global.html#focusPreviousElementOnDismiss">focusPreviousElementOnDismiss</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAriaLabel">getAriaLabel</a></li><li><a href="global.html#getDateTime">getDateTime</a></li><li><a href="global.html#getDateValue">getDateValue</a></li><li><a href="global.html#getElementChildren">getElementChildren</a></li><li><a href="global.html#getElementRoot">getElementRoot</a></li><li><a href="global.html#getPendingOrdersAsync">getPendingOrdersAsync</a></li><li><a href="global.html#getStockAsync">getStockAsync</a></li><li><a href="global.html#getTimeGivenProgression">getTimeGivenProgression</a></li><li><a href="global.html#h">h</a></li><li><a href="global.html#handleToolbarIntersection">handleToolbarIntersection</a></li><li><a href="global.html#hapticAvailable">hapticAvailable</a></li><li><a href="global.html#hapticImpact">hapticImpact</a></li><li><a href="global.html#hapticNotification">hapticNotification</a></li><li><a href="global.html#hapticSelection">hapticSelection</a></li><li><a href="global.html#hapticSelectionChanged">hapticSelectionChanged</a></li><li><a href="global.html#hapticSelectionEnd">hapticSelectionEnd</a></li><li><a href="global.html#hapticSelectionStart">hapticSelectionStart</a></li><li><a href="global.html#inheritAttributes">inheritAttributes</a></li><li><a href="global.html#initAngular1">initAngular1</a></li><li><a href="global.html#iosEnterAnimation">iosEnterAnimation</a></li><li><a href="global.html#iosLeaveAnimation">iosLeaveAnimation</a></li><li><a href="global.html#isEndSide">isEndSide</a></li><li><a href="global.html#keyboardDidClose">keyboardDidClose</a></li><li><a href="global.html#keyboardDidOpen">keyboardDidOpen</a></li><li><a href="global.html#keyboardDidResize">keyboardDidResize</a></li><li><a href="global.html#lex">lex</a></li><li><a href="global.html#mdEnterAnimation">mdEnterAnimation</a></li><li><a href="global.html#mdLeaveAnimation">mdLeaveAnimation</a></li><li><a href="global.html#menuOverlayAnimation">menuOverlayAnimation</a></li><li><a href="global.html#menuPushAnimation">menuPushAnimation</a></li><li><a href="global.html#menuRevealAnimation">menuRevealAnimation</a></li><li><a href="global.html#Methods">Methods</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#parseCss">parseCss</a></li><li><a href="global.html#processKeyframes">processKeyframes</a></li><li><a href="global.html#raf">raf</a></li><li><a href="global.html#register">register</a></li><li><a href="global.html#renderHiddenInput">renderHiddenInput</a></li><li><a href="global.html#resetKeyboardAssist">resetKeyboardAssist</a></li><li><a href="global.html#s">s</a></li><li><a href="global.html#safeSelector">safeSelector</a></li><li><a href="global.html#sanitizeDOMString">sanitizeDOMString</a></li><li><a href="global.html#sanitizeElement">sanitizeElement</a></li><li><a href="global.html#setAccessor">setAccessor</a></li><li><a href="global.html#showIonicModal">showIonicModal</a></li><li><a href="global.html#solveCubicBezier">solveCubicBezier</a></li><li><a href="global.html#solveCubicParametricEquation">solveCubicParametricEquation</a></li><li><a href="global.html#startNativeListeners">startNativeListeners</a></li><li><a href="global.html#StyleNode">StyleNode</a></li><li><a href="global.html#SVG_NS">SVG_NS</a></li><li><a href="global.html#trackViewportChanges">trackViewportChanges</a></li><li><a href="global.html#trapKeyboardFocus">trapKeyboardFocus</a></li><li><a href="global.html#types">types</a></li><li><a href="global.html#updatePendingOrders">updatePendingOrders</a></li><li><a href="global.html#updateStock">updateStock</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>resources/ionic-core/dist/collection/utils/overlays.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { config } from '../global/config';
import { getIonMode } from '../global/ionic-global';
import { OVERLAY_BACK_BUTTON_PRIORITY } from './hardware-back-button';
import { addEventListener, componentOnReady, getElementRoot, removeEventListener } from './helpers';
let lastId = 0;
export const activeAnimations = new WeakMap();
const createController = (tagName) => {
  return {
    create(options) {
      return createOverlay(tagName, options);
    },
    dismiss(data, role, id) {
      return dismissOverlay(document, data, role, tagName, id);
    },
    async getTop() {
      return getOverlay(document, tagName);
    }
  };
};
export const alertController = /*@__PURE__*/ createController('ion-alert');
export const actionSheetController = /*@__PURE__*/ createController('ion-action-sheet');
export const loadingController = /*@__PURE__*/ createController('ion-loading');
export const modalController = /*@__PURE__*/ createController('ion-modal');
export const pickerController = /*@__PURE__*/ createController('ion-picker');
export const popoverController = /*@__PURE__*/ createController('ion-popover');
export const toastController = /*@__PURE__*/ createController('ion-toast');
export const prepareOverlay = (el) => {
  /* tslint:disable-next-line */
  if (typeof document !== 'undefined') {
    connectListeners(document);
  }
  const overlayIndex = lastId++;
  el.overlayIndex = overlayIndex;
  if (!el.hasAttribute('id')) {
    el.id = `ion-overlay-${overlayIndex}`;
  }
};
export const createOverlay = (tagName, opts) => {
  /* tslint:disable-next-line */
  if (typeof customElements !== 'undefined') {
    return customElements.whenDefined(tagName).then(() => {
      const element = document.createElement(tagName);
      element.classList.add('overlay-hidden');
      // convert the passed in overlay options into props
      // that get passed down into the new overlay
      Object.assign(element, opts);
      // append the overlay element to the document body
      getAppRoot(document).appendChild(element);
      return new Promise(resolve => componentOnReady(element, resolve));
    });
  }
  return Promise.resolve();
};
const focusableQueryString = '[tabindex]:not([tabindex^="-"]), input:not([type=hidden]):not([tabindex^="-"]), textarea:not([tabindex^="-"]), button:not([tabindex^="-"]), select:not([tabindex^="-"]), .ion-focusable:not([tabindex^="-"])';
const innerFocusableQueryString = 'input:not([type=hidden]), textarea, button, select';
const focusFirstDescendant = (ref, overlay) => {
  let firstInput = ref.querySelector(focusableQueryString);
  const shadowRoot = firstInput &amp;&amp; firstInput.shadowRoot;
  if (shadowRoot) {
    // If there are no inner focusable elements, just focus the host element.
    firstInput = shadowRoot.querySelector(innerFocusableQueryString) || firstInput;
  }
  if (firstInput) {
    firstInput.focus();
  }
  else {
    // Focus overlay instead of letting focus escape
    overlay.focus();
  }
};
const focusLastDescendant = (ref, overlay) => {
  const inputs = Array.from(ref.querySelectorAll(focusableQueryString));
  let lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;
  const shadowRoot = lastInput &amp;&amp; lastInput.shadowRoot;
  if (shadowRoot) {
    // If there are no inner focusable elements, just focus the host element.
    lastInput = shadowRoot.querySelector(innerFocusableQueryString) || lastInput;
  }
  if (lastInput) {
    lastInput.focus();
  }
  else {
    // Focus overlay instead of letting focus escape
    overlay.focus();
  }
};
/**
 * Traps keyboard focus inside of overlay components.
 * Based on https://w3c.github.io/aria-practices/examples/dialog-modal/alertdialog.html
 * This includes the following components: Action Sheet, Alert, Loading, Modal,
 * Picker, and Popover.
 * Should NOT include: Toast
 */
const trapKeyboardFocus = (ev, doc) => {
  const lastOverlay = getOverlay(doc);
  const target = ev.target;
  // If no active overlay, ignore this event
  if (!lastOverlay || !target) {
    return;
  }
  /**
   * If we are focusing the overlay, clear
   * the last focused element so that hitting
   * tab activates the first focusable element
   * in the overlay wrapper.
   */
  if (lastOverlay === target) {
    lastOverlay.lastFocus = undefined;
    /**
     * Otherwise, we must be focusing an element
     * inside of the overlay. The two possible options
     * here are an input/button/etc or the ion-focus-trap
     * element. The focus trap element is used to prevent
     * the keyboard focus from leaving the overlay when
     * using Tab or screen assistants.
     */
  }
  else {
    /**
     * We do not want to focus the traps, so get the overlay
     * wrapper element as the traps live outside of the wrapper.
     */
    const overlayRoot = getElementRoot(lastOverlay);
    if (!overlayRoot.contains(target)) {
      return;
    }
    const overlayWrapper = overlayRoot.querySelector('.ion-overlay-wrapper');
    if (!overlayWrapper) {
      return;
    }
    /**
     * If the target is inside the wrapper, let the browser
     * focus as normal and keep a log of the last focused element.
     */
    if (overlayWrapper.contains(target)) {
      lastOverlay.lastFocus = target;
    }
    else {
      /**
       * Otherwise, we must have focused one of the focus traps.
       * We need to wrap the focus to either the first element
       * or the last element.
       */
      /**
       * Once we call `focusFirstDescendant` and focus the first
       * descendant, another focus event will fire which will
       * cause `lastOverlay.lastFocus` to be updated before
       * we can run the code after that. We will cache the value
       * here to avoid that.
       */
      const lastFocus = lastOverlay.lastFocus;
      // Focus the first element in the overlay wrapper
      focusFirstDescendant(overlayWrapper, lastOverlay);
      /**
       * If the cached last focused element is the
       * same as the active element, then we need
       * to wrap focus to the last descendant. This happens
       * when the first descendant is focused, and the user
       * presses Shift + Tab. The previous line will focus
       * the same descendant again (the first one), causing
       * last focus to equal the active element.
       */
      if (lastFocus === doc.activeElement) {
        focusLastDescendant(overlayWrapper, lastOverlay);
      }
      lastOverlay.lastFocus = doc.activeElement;
    }
  }
};
export const connectListeners = (doc) => {
  if (lastId === 0) {
    lastId = 1;
    doc.addEventListener('focus', ev => trapKeyboardFocus(ev, doc), true);
    // handle back-button click
    doc.addEventListener('ionBackButton', ev => {
      const lastOverlay = getOverlay(doc);
      if (lastOverlay &amp;&amp; lastOverlay.backdropDismiss) {
        ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, () => {
          return lastOverlay.dismiss(undefined, BACKDROP);
        });
      }
    });
    // handle ESC to close overlay
    doc.addEventListener('keyup', ev => {
      if (ev.key === 'Escape') {
        const lastOverlay = getOverlay(doc);
        if (lastOverlay &amp;&amp; lastOverlay.backdropDismiss) {
          lastOverlay.dismiss(undefined, BACKDROP);
        }
      }
    });
  }
};
export const dismissOverlay = (doc, data, role, overlayTag, id) => {
  const overlay = getOverlay(doc, overlayTag, id);
  if (!overlay) {
    return Promise.reject('overlay does not exist');
  }
  return overlay.dismiss(data, role);
};
export const getOverlays = (doc, selector) => {
  if (selector === undefined) {
    selector = 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast';
  }
  return Array.from(doc.querySelectorAll(selector))
    .filter(c => c.overlayIndex > 0);
};
export const getOverlay = (doc, overlayTag, id) => {
  const overlays = getOverlays(doc, overlayTag);
  return (id === undefined)
    ? overlays[overlays.length - 1]
    : overlays.find(o => o.id === id);
};
export const present = async (overlay, name, iosEnterAnimation, mdEnterAnimation, opts) => {
  if (overlay.presented) {
    return;
  }
  overlay.presented = true;
  overlay.willPresent.emit();
  const mode = getIonMode(overlay);
  // get the user's animation fn if one was provided
  const animationBuilder = (overlay.enterAnimation)
    ? overlay.enterAnimation
    : config.get(name, mode === 'ios' ? iosEnterAnimation : mdEnterAnimation);
  const completed = await overlayAnimation(overlay, animationBuilder, overlay.el, opts);
  if (completed) {
    overlay.didPresent.emit();
  }
  /**
   * When an overlay that steals focus
   * is dismissed, focus should be returned
   * to the element that was focused
   * prior to the overlay opening. Toast
   * does not steal focus and is excluded
   * from returning focus as a result.
   */
  if (overlay.el.tagName !== 'ION-TOAST') {
    focusPreviousElementOnDismiss(overlay.el);
  }
  if (overlay.keyboardClose) {
    overlay.el.focus();
  }
};
/**
 * When an overlay component is dismissed,
 * focus should be returned to the element
 * that presented the overlay. Otherwise
 * focus will be set on the body which
 * means that people using screen readers
 * or tabbing will need to re-navigate
 * to where they were before they
 * opened the overlay.
 */
const focusPreviousElementOnDismiss = async (overlayEl) => {
  let previousElement = document.activeElement;
  if (!previousElement) {
    return;
  }
  const shadowRoot = previousElement &amp;&amp; previousElement.shadowRoot;
  if (shadowRoot) {
    // If there are no inner focusable elements, just focus the host element.
    previousElement = shadowRoot.querySelector(innerFocusableQueryString) || previousElement;
  }
  await overlayEl.onDidDismiss();
  previousElement.focus();
};
export const dismiss = async (overlay, data, role, name, iosLeaveAnimation, mdLeaveAnimation, opts) => {
  if (!overlay.presented) {
    return false;
  }
  overlay.presented = false;
  try {
    // Overlay contents should not be clickable during dismiss
    overlay.el.style.setProperty('pointer-events', 'none');
    overlay.willDismiss.emit({ data, role });
    const mode = getIonMode(overlay);
    const animationBuilder = (overlay.leaveAnimation)
      ? overlay.leaveAnimation
      : config.get(name, mode === 'ios' ? iosLeaveAnimation : mdLeaveAnimation);
    // If dismissed via gesture, no need to play leaving animation again
    if (role !== 'gesture') {
      await overlayAnimation(overlay, animationBuilder, overlay.el, opts);
    }
    overlay.didDismiss.emit({ data, role });
    activeAnimations.delete(overlay);
  }
  catch (err) {
    console.error(err);
  }
  overlay.el.remove();
  return true;
};
const getAppRoot = (doc) => {
  return doc.querySelector('ion-app') || doc.body;
};
const overlayAnimation = async (overlay, animationBuilder, baseEl, opts) => {
  // Make overlay visible in case it's hidden
  baseEl.classList.remove('overlay-hidden');
  const aniRoot = baseEl.shadowRoot || overlay.el;
  const animation = animationBuilder(aniRoot, opts);
  if (!overlay.animated || !config.getBoolean('animated', true)) {
    animation.duration(0);
  }
  if (overlay.keyboardClose) {
    animation.beforeAddWrite(() => {
      const activeElement = baseEl.ownerDocument.activeElement;
      if (activeElement &amp;&amp; activeElement.matches('input, ion-input, ion-textarea')) {
        activeElement.blur();
      }
    });
  }
  const activeAni = activeAnimations.get(overlay) || [];
  activeAnimations.set(overlay, [...activeAni, animation]);
  await animation.play();
  return true;
};
export const eventMethod = (element, eventName) => {
  let resolve;
  const promise = new Promise(r => resolve = r);
  onceEvent(element, eventName, (event) => {
    resolve(event.detail);
  });
  return promise;
};
export const onceEvent = (element, eventName, callback) => {
  const handler = (ev) => {
    removeEventListener(element, eventName, handler);
    callback(ev);
  };
  addEventListener(element, eventName, handler);
};
export const isCancel = (role) => {
  return role === 'cancel' || role === BACKDROP;
};
const defaultGate = (h) => h();
export const safeCall = (handler, arg) => {
  if (typeof handler === 'function') {
    const jmp = config.get('_zoneGate', defaultGate);
    return jmp(() => {
      try {
        return handler(arg);
      }
      catch (e) {
        console.error(e);
      }
    });
  }
  return undefined;
};
export const BACKDROP = 'backdrop';
</code></pre>
        </article>
    </section>




            </div>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/search.js"> </script>

</body>
</html>
